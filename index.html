<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kolpingtheater Ramsen - Drehbuch Viewer</title>
    <style>
      /* General Styles */
      body {
        font-family: Arial, sans-serif;
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
        background: #f0f2f5;
        transition: background 0.3s, color 0.3s;
      }

      body.dark-mode {
        background: #1a202c;
        color: #cbd5e0;
      }

      .controls {
        background: white;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: background 0.3s, color 0.3s;
      }

      body.dark-mode .controls {
        background: #2d3748;
        color: #cbd5e0;
      }

      .script-container {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: background 0.3s, color 0.3s;
      }

      body.dark-mode .script-container {
        background: #2d3748;
        color: #cbd5e0;
      }

      .script-line {
        padding: 10px;
        margin: 5px 0;
        border-radius: 4px;
        transition: background 0.3s, color 0.3s;
      }

      body.dark-mode .script-line {
        background: #4a5568;
      }

      .actor-name {
        font-weight: bold;
        color: #2c5282;
      }

      body.dark-mode .actor-name {
        color: #63b3ed;
      }

      .instruction {
        background: #f7fafc;
        font-style: italic;
        color: #4a5568;
      }

      body.dark-mode .instruction {
        background: #2d3748;
        color: #a0aec0;
      }

      .technical {
        background: #f3e8ff;
        color: #6b21a8;
      }

      body.dark-mode .technical {
        background: #553c9a;
        color: #d6bcfa;
      }

      .lighting {
        background: #fffbeb;
        color: #92400e;
      }

      body.dark-mode .lighting {
        background: #744210;
        color: #fbd38d;
      }

      .audio {
        background: rgba(128, 255, 136, 0.39);
        color: #1a202c;
      }

      body.dark-mode .audio {
        background: #1a202c;
        color: rgb(128, 255, 136, 0.7);
      }

      .highlighted {
        background: #ebf8ff;
        border-left: 4px solid #3182ce;
        padding-left: 15px;
      }

      body.dark-mode .highlighted {
        background: #2b6cb0;
        border-left: 4px solid #63b3ed;
      }

      .micro {
        font-size: 0.875rem;
        color: #718096;
        margin-top: 4px;
      }

      body.dark-mode .micro {
        color: #a0aec0;
      }

      .tag {
        border-radius: 4px;
        font-size: 0.7rem;
        text-transform: uppercase;
        font-weight: bold;
        width: fit-content;
      }

      .scene-separator {
        border-top: 2px solid #4299e1;
        margin: 0 30px 0 0;
        padding-bottom: 20px;
      }

      body.dark-mode .scene-separator {
        border-top: 2px solid #63b3ed;
      }

      h2 {
        margin-top: 30px;
        color: black;
      }

      body.dark-mode h2 {
        color: #cbd5e0;
      }

      .scene-overview {
        background: #ebf8ff;
        padding: 15px;
        border-radius: 4px;
        margin-bottom: 20px;
      }

      body.dark-mode .scene-overview {
        background: #2b6cb0;
      }

      .scene-overview h3 {
        margin-top: 0;
        color: #2c5282;
      }

      body.dark-mode .scene-overview h3 {
        color: #63b3ed;
      }

      .toc {
        background: #f7fafc;
        padding: 15px;
        border-radius: 4px;
        margin-bottom: 20px;
      }

      body.dark-mode .toc {
        background: #2d3748;
      }

      .toc a {
        display: block;
        margin-bottom: 10px;
        text-decoration: none;
        color: #2c5282;
        width: fit-content;
        padding-left: 10px;
      }

      body.dark-mode .toc a {
        color: #63b3ed;
      }

      /* Print Styles */
      @media print {
        .controls,
        .no-print {
          display: none !important;
        }

        body {
          background: white;
          padding: 0;
          margin: 0;
        }

        .script-container {
          box-shadow: none;
          padding: 0;
          margin: 32px;
        }

        .script-line {
          break-inside: avoid;
        }
      }

      /* Buttons */
      button {
        background: #4299e1;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1rem;
        margin-right: 10px;
      }

      button:hover {
        background: #3182ce;
      }

      /* Select and Checkbox Styles */
      .select-container {
        position: relative;
        width: 100%;
      }

      .select-container::after {
        content: '▼';
        font-size: 0.8em;
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: #4299e1;
        pointer-events: none;
        transition: transform 0.2s ease;
      }

      body.dark-mode .select-container::after {
        color: #63b3ed;
      }

      select {
        width: 100%;
        padding: 10px 35px 10px 12px;
        border-radius: 6px;
        border: 2px solid #e2e8f0;
        background: white;
        font-size: 1rem;
        color: #2d3748;
        appearance: none;
        cursor: pointer;
        transition: all 0.2s ease;
        margin: 8px 0;
      }

      select:hover {
        border-color: #4299e1;
      }

      select:focus {
        outline: none;
        border-color: #4299e1;
        box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.2);
      }

      body.dark-mode select {
        background: #2d3748;
        color: #cbd5e0;
        border-color: #4a5568;
      }

      body.dark-mode select:hover {
        border-color: #63b3ed;
      }

      body.dark-mode select:focus {
        border-color: #63b3ed;
        box-shadow: 0 0 0 3px rgba(99, 179, 237, 0.2);
      }

      /* Style for select options */
      select option {
        padding: 10px;
      }

      body.dark-mode select option {
        background: #2d3748;
      }

      /* Checkbox group styles */
      .checkbox-group {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 12px;
        cursor: pointer;
      }

      .checkbox-group input[type="checkbox"] {
        appearance: none;
        width: 18px;
        height: 18px;
        border: 2px solid #e2e8f0;
        border-radius: 4px;
        cursor: pointer;
        position: relative;
        transition: all 0.2s ease;
      }

      .checkbox-group input[type="checkbox"]:checked {
        background: #4299e1;
        border-color: #4299e1;
      }

      .checkbox-group input[type="checkbox"]:checked::after {
        content: '✓';
        color: white;
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        font-size: 12px;
      }

      .checkbox-group input[type="checkbox"]:hover {
        border-color: #4299e1;
      }

      .checkbox-group input[type="checkbox"]:focus {
        outline: none;
        box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.2);
      }

      body.dark-mode .checkbox-group input[type="checkbox"] {
        border-color: #4a5568;
      }

      body.dark-mode .checkbox-group input[type="checkbox"]:checked {
        background: #63b3ed;
        border-color: #63b3ed;
      }

      body.dark-mode .checkbox-group input[type="checkbox"]:hover {
        border-color: #63b3ed;
      }

      .checkbox-group label {
        user-select: none;
      }

      /* Mobile Navigation */
      .nav-toggle {
        display: none;
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
        background: #4299e1;
        color: white;
        border: none;
        padding: 10px;
        border-radius: 4px;
        cursor: pointer;
      }

      .sidebar {
        position: fixed;
        top: 0;
        right: -350px;
        width: 300px;
        height: 100vh;
        background: white;
        box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
        transition: right 0.3s ease;
        z-index: 999;
        overflow-y: auto;
        padding: 20px;
      }

      body.dark-mode .sidebar {
        background: #2d3748;
      }

      .sidebar.active {
        right: 0;
      }

      .sidebar-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 998;
      }

      .sidebar-overlay.active {
        display: block;
      }

      @media (max-width: 768px) {
        .nav-toggle {
          display: block;
        }

        .toc {
          display: none;
        }

        body {
          padding: 20px 10px;
        }

        .controls {
          padding: 15px;
          margin-bottom: 15px;
        }
      }

      /* Navigation Bar */
      .nav-bar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: white;
        padding: 15px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        z-index: 997;
        transition: background 0.3s;
      }

      body.dark-mode .nav-bar {
        background: #2d3748;
      }

      .nav-bar h1 {
        margin: 0;
        font-size: 1.5rem;
        flex-grow: 1;
      }

      .nav-toggle {
        display: block;
        position: static;
        padding: 8px 12px;
        margin-left: 15px;
        font-size: 1.2rem;
      }

      /* Remove old nav-toggle styles */
      @media (max-width: 768px) {
        .nav-toggle {
          padding: 6px 10px;
          font-size: 1rem;
        }

        .nav-bar h1 {
          font-size: 1.2rem;
        }
      }

      /* Adjust main content to account for fixed nav */
      body {
        padding-top: 70px;
      }

      /* Update mobile styles */
      @media (max-width: 768px) {
        .nav-bar {
          padding: 10px 15px;
        }

        .nav-bar h1 {
          font-size: 1.2rem;
        }

        body {
          padding-top: 60px;
        }

        .controls h1 {
          display: none;
        }
      }

      /* Update sidebar styles */
      .sidebar {
        padding-top: 70px;
      }

      .sidebar .toc {
        display: block;
        margin: 0;
        background: none;
        padding: 0;
      }

      /* Update controls spacing */
      .controls {
        margin-top: 20px;
      }

      /* Add Pink Mode Styles */
      body.pink-mode {
        background: #fff0f6;
        color: #702459;
      }

      body.pink-mode .controls,
      body.pink-mode .script-container,
      body.pink-mode .nav-bar,
      body.pink-mode .sidebar {
        background: #fff5f7;
      }

      body.pink-mode .script-line {
        background: #fff5f7;
      }

      body.pink-mode .actor-name {
        color: #d53f8c;
      }

      body.pink-mode .instruction {
        background: #fdf2f8;
        color: #702459;
      }

      body.pink-mode .technical {
        background: #fdf2f8;
        color: #97266d;
      }

      body.pink-mode .lighting {
        background: #fdf2f8;
        color: #97266d;
      }

      body.pink-mode .audio {
        background: #fdf2f8;
        color: #97266d;
      }

      body.pink-mode .highlighted {
        background: #fdf2f8;
        border-left: 4px solid #d53f8c;
      }

      body.pink-mode .scene-separator {
        border-top: 2px solid #d53f8c;
      }

      body.pink-mode .scene-overview {
        background: #fdf2f8;
      }

      body.pink-mode .scene-overview h3 {
        color: #97266d;
      }

      body.pink-mode .toc {
        background: #fdf2f8;
      }

      body.pink-mode .toc a {
        color: #97266d;
      }

      body.pink-mode button {
        background: #d53f8c;
      }

      body.pink-mode button:hover {
        background: #97266d;
      }

      body.pink-mode .select-container::after {
        color: #d53f8c;
      }

      body.pink-mode select {
        border-color: #feb2d0;
      }

      body.pink-mode select:hover,
      body.pink-mode select:focus {
        border-color: #d53f8c;
        box-shadow: 0 0 0 3px rgba(213, 63, 140, 0.2);
      }

      body.pink-mode .checkbox-group input[type="checkbox"] {
        border-color: #feb2d0;
      }

      body.pink-mode .checkbox-group input[type="checkbox"]:checked {
        background: #d53f8c;
        border-color: #d53f8c;
      }

      body.pink-mode .checkbox-group input[type="checkbox"]:hover {
        border-color: #d53f8c;
      }

      body.pink-mode .nav-bar .current-scene {
        color: #d53f8c;
      }

      /* Add this CSS after the nav-bar styles */
      .bottom-nav {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: white;
        padding: 15px 20px;
        display: none; /* Hidden by default */
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
        z-index: 997;
        transition: background 0.3s;
      }

      body.dark-mode .bottom-nav {
        background: #2d3748;
      }

      body.pink-mode .bottom-nav {
        background: #fff5f7;
      }

      .bottom-nav button {
        margin: 0 5px;
      }

      /* Add padding to prevent content from being hidden behind the bottom nav */
      body.has-bottom-nav {
        padding-bottom: 70px;
      }

      @media (max-width: 768px) {
        .bottom-nav {
          padding: 8px 10px;
        }

        .bottom-nav button {
          font-size: 0.9rem;
          padding: 6px 10px;
        }

        #current-line-info {
          font-size: 0.9rem;
        }
      }

      /* Add after your existing animations */
      @keyframes flash-highlight {
        0% { background-color: rgba(66, 153, 225, 0.8); }
        100% { background-color: transparent; }
      }

      @keyframes flash-highlight-dark {
        0% { background-color: rgba(99, 179, 237, 0.8); }
        100% { background-color: transparent; }
      }

      @keyframes flash-highlight-pink {
        0% { background-color: rgba(213, 63, 140, 0.8); }
        100% { background-color: transparent; }
      }

      .flash-highlight {
        animation: flash-highlight 1s ease-out forwards;
      }

      body.dark-mode .flash-highlight {
        animation-name: flash-highlight-dark;
      }

      body.pink-mode .flash-highlight {
        animation-name: flash-highlight-pink;
      }
    </style>
    <script src="papaparse.min.js"></script>
    <script>
      // Load and parse CSV
      async function loadScript() {
        try {
          // Check cache first
          const cachedData = localStorage.getItem('scriptData')
          const lastFetch = localStorage.getItem('scriptLastFetch')
          const cacheAge = lastFetch ? Date.now() - parseInt(lastFetch) : Infinity
          
          // Use cache if it exists and is less than 5 minutes old
          if (cachedData && cacheAge < 5 * 60 * 1000) {
            return JSON.parse(cachedData)
          }

          const response = await fetch(
            'https://docs.google.com/spreadsheets/d/1LEhNzES1aLQ_UVA8esjXcGgkK3I5gv3q/export?format=csv&gid=2016971711'
          )
          
          if (!response.ok) {
            // If fetch fails and we have cached data, use it regardless of age
            if (cachedData) {
              console.log('Failed to fetch new data, using cached data')
              return JSON.parse(cachedData)
            }
            throw new Error('Network response was not ok')
          }

          const csvText = await response.text()
          const data = Papa.parse(csvText, { header: true }).data

          // Only update cache if we got valid data
          if (data && data.length > 0) {
            localStorage.setItem('scriptData', JSON.stringify(data))
            localStorage.setItem('scriptLastFetch', Date.now().toString())
          }

          return data
        } catch (error) {
          console.error('Error loading script:', error)
          // Try to return cached data if available
          const cachedData = localStorage.getItem('scriptData')
          if (cachedData) {
            console.log('Error fetching new data, using cached data')
            return JSON.parse(cachedData)
          }
          return []
        }
      }

      // # "Szene","Kategorie","Charakter","Mikrofon","Text/Anweisung"

      // Populate actors dropdown
      function populateActors(data) {
        const actors = [
          ...new Set(
            data
              .filter((row) => row.Charakter)
              .map((row) => row.Charakter.trim())
          ),
        ].sort()

        const select = document.getElementById('actor-select')
        select.innerHTML = '<option value="">Alle Charaktere</option>'
        actors.forEach((actor) => {
          const option = document.createElement('option')
          option.value = actor
          option.textContent = actor
          select.appendChild(option)
        })
      }

      // ToC
      function createToC(data, selectedActor) {
        // Get all scenes & actors in each scene
        const scenes = new Map()
        data.forEach((row) => {
          if (!scenes.has(row.Szene)) {
            scenes.set(row.Szene, new Set())
          }
          if (row.Charakter) scenes.get(row.Szene).add(row.Charakter)
        })

        const createTocContent = () => {
          const toc = document.createElement('div')
          toc.className = 'toc'

          const title = document.createElement('h2')
          title.textContent = 'Inhaltsverzeichnis'
          toc.appendChild(title)

          scenes.forEach((actors, scene) => {
            const a = document.createElement('a')
            a.href = `#scene-${scene}`
            if (actors.has(selectedActor)) {
              a.style.fontWeight = 'bold'
              a.style.borderLeft = '4px solid #4299e1'
            }
            a.textContent = `Szene ${scene}`
            a.onclick = () => {
              if (window.innerWidth <= 768) {
                closeSidebar()
              }
              updateCurrentScene()
            }
            toc.appendChild(a)
          })

          return toc
        }

        // Create and return TOC for main content
        const mainToc = createTocContent()
        
        // Create and update sidebar TOC
        const sidebarToc = createTocContent()
        const sidebar = document.querySelector('.sidebar')
        if (sidebar) {
          sidebar.innerHTML = ''
          sidebar.appendChild(sidebarToc)
        }

        return mainToc
      }

      // Create scene overview
      function createSceneOverview(sceneData, selectedActor) {
        let actors = new Set()
        const micros = new Map()

        sceneData.forEach((row) => {
          if (row.Charakter) {
            actors.add(row.Charakter.trim())
            if (row.Mikrofon) {
              micros.set(row.Charakter, row.Mikrofon)
            }
          }
        })

        if (actors.size === 0) return document.createElement('div')

        const overview = document.createElement('div')
        overview.className = 'scene-overview'

        const title = document.createElement('h3')
        title.textContent = 'Szenenübersicht'
        overview.appendChild(title)

        const table = document.createElement('table')

        const tr = document.createElement('tr')
        const th1 = document.createElement('th')
        th1.textContent = 'Mikro'
        tr.appendChild(th1)
        const th2 = document.createElement('th')
        th2.textContent = 'Schauspieler'
        tr.appendChild(th2)
        table.appendChild(tr)

        // Sort actors by micro and try to parse micros as numbers
        actors = Array.from(actors).sort((a, b) => {
          const microA = parseInt(micros.get(a), 10)
          const microB = parseInt(micros.get(b), 10)
          return microA - microB
        })

        actors.forEach((actor) => {
          const tr = document.createElement('tr')
          const td1 = document.createElement('td')
          td1.textContent = micros.get(actor) || ''
          tr.appendChild(td1)
          const td2 = document.createElement('td')
          td2.innerHTML = selectedActor === actor ? `<b>${actor}</b>` : actor
          tr.appendChild(td2)
          table.appendChild(tr)
        })

        overview.appendChild(table)

        return overview
      }

      // Render script
      function renderScript(data) {
        const container = document.getElementById('script-container')
        const selectedActor = document.getElementById('actor-select').value
        const showDirections = document.getElementById('show-directions').checked
        const showTechnical = document.getElementById('show-technical').checked
        const showLighting = document.getElementById('show-lighting').checked
        const showActorText = document.getElementById('show-actor-text').checked
        const showMicro = document.getElementById('show-micro').checked
        const showEinspieler = document.getElementById('show-einspieler').checked
        const showSceneOverview = document.getElementById('show-scene-overview').checked
        const blurLines = document.getElementById('blur-lines').checked

        container.innerHTML = ''

        const toc = createToC(data, selectedActor)
        container.appendChild(toc)

        let currentScene = ''
        let sceneData = []

        data.forEach((row, index) => {
          // Check for new scene
          const isNewScene = row.Szene !== currentScene

          if (isNewScene) {
            const a = document.createElement('a')
            a.name = `scene-${row.Szene}`
            container.appendChild(a)
            const szeneTitel = document.createElement('h2')
            szeneTitel.textContent = `Szene ${row.Szene}`
            container.appendChild(szeneTitel)
            const separator = document.createElement('div')
            separator.className = 'scene-separator'
            container.appendChild(separator)

            if (showSceneOverview) {
              for (let i = index; i < data.length; i++) {
                if (data[i].Szene === row.Szene) {
                  sceneData.push(data[i])
                } else {
                  break
                }
              }
              if (sceneData.length > 0) {
                container.appendChild(createSceneOverview(sceneData, selectedActor))
              }
              sceneData = []
            }
            currentScene = row.Szene
          }

          // Apply filters
          if (!showDirections && row.Kategorie === 'Anweisung') return
          if (!showTechnical && row.Kategorie === 'Technik') return
          if (!showLighting && row.Kategorie === 'Licht') return
          if (!showEinspieler && row.Kategorie === 'Einspieler') return
          if (!showActorText && row.Charakter) return

          const div = document.createElement('div')
          div.className = 'script-line'

          // Apply styling based on type
          if (row.Kategorie === 'Anweisung') {
            div.classList.add('instruction')
          } else if (row.Kategorie === 'Szenenbeginn') {
            div.style.display = 'none'
          } else if (row.Kategorie === 'Einspieler') {
            div.classList.add('audio')
            const audioSpan = document.createElement('div')
            audioSpan.className = 'tag'
            audioSpan.textContent = 'Einspieler'
            div.appendChild(audioSpan)
          } else if (row.Kategorie === 'Technik') {
            const techSpan = document.createElement('div')
            techSpan.className = 'tag'
            techSpan.textContent = 'Technik'
            div.appendChild(techSpan)
            div.classList.add('technical')
          } else if (row.Kategorie === 'Licht') {
            const lightSpan = document.createElement('div')
            lightSpan.className = 'tag'
            lightSpan.textContent = 'Licht'
            div.appendChild(lightSpan)
            div.classList.add('lighting')
          } else if (row.Charakter === selectedActor && selectedActor) {
            div.classList.add('highlighted')
            if (blurLines) {
              div.style.filter = 'blur(4px)'
              div.style.cursor = 'pointer'
              div.addEventListener('click', () => {
                div.style.filter = div.style.filter === 'none' ? 'blur(4px)' : 'none'
              })
            }
          }

          // Create content
          if (row.Charakter) {
            const nameSpan = document.createElement('div')
            nameSpan.className = 'actor-name'
            nameSpan.textContent = row.Mikrofon && showMicro
              ? `${row.Charakter} (${row.Mikrofon})`
              : row.Charakter
            div.appendChild(nameSpan)
          }

          const textDiv = document.createElement('div')
          textDiv.textContent = row['Text/Anweisung']

          // Bold text for instruction
          if (row.Kategorie === 'Anweisung') {
            textDiv.innerHTML = textDiv.textContent.replace(
              selectedActor,
              `<b>${selectedActor}</b>`
            )
          }

          div.appendChild(textDiv)
          container.appendChild(div)
        })

        // Update bottom navigation after rendering
        updateBottomNav()
      }

      // Save state to localStorage
      function saveState() {
        const checkboxes = document.querySelectorAll('#checkboxes input')
        checkboxes.forEach((checkbox) => {
          localStorage.setItem(checkbox.id, checkbox.checked)
        })
        const actorSelect = document.getElementById('actor-select')
        localStorage.setItem('actor-select', actorSelect.value)
        localStorage.setItem('dark-mode', document.body.classList.contains('dark-mode'))
        localStorage.setItem('pink-mode', document.body.classList.contains('pink-mode'))
      }

      // Load state from localStorage
      function loadState() {
        const checkboxes = document.querySelectorAll('#checkboxes input')
        checkboxes.forEach((checkbox) => {
          const storedValue = localStorage.getItem(checkbox.id)
          if (storedValue !== null) {
            checkbox.checked = storedValue === 'true'
          }
        })
        const actorSelect = document.getElementById('actor-select')
        actorSelect.value = localStorage.getItem('actor-select') || ''
        
        // Load theme modes
        const darkMode = localStorage.getItem('dark-mode') === 'true'
        const pinkMode = localStorage.getItem('pink-mode') === 'true'
        document.body.classList.toggle('dark-mode', darkMode)
        document.body.classList.toggle('pink-mode', pinkMode)
        document.getElementById('dark-mode').checked = darkMode
        document.getElementById('pink-mode').checked = pinkMode
      }

      // Initialize
      async function init() {
        const data = await loadScript()
        window.scriptData = data
        populateActors(data)
        loadState()

        // Add event listeners
        document.querySelectorAll('#checkboxes input').forEach((input) => {
          input.addEventListener('change', () => {
            saveState()
            renderScript(data)
          })
        })

        document
          .getElementById('actor-select')
          .addEventListener('change', () => {
            saveState()
            renderScript(data)
          })

        document.getElementById('pink-mode').addEventListener('change', (e) => {
          if (e.target.checked) {
            document.body.classList.remove('dark-mode')
            document.getElementById('dark-mode').checked = false
            document.body.classList.add('pink-mode')
          } else {
            document.body.classList.remove('pink-mode')
          }
          saveState()
        })

        document.getElementById('dark-mode').addEventListener('change', (e) => {
          if (e.target.checked) {
            document.body.classList.remove('pink-mode')
            document.getElementById('pink-mode').checked = false
            document.body.classList.add('dark-mode')
          } else {
            document.body.classList.remove('dark-mode')
          }
          saveState()
        })

        // Add scroll event listener for updating current scene
        window.addEventListener('scroll', () => {
          updateCurrentScene()
          updateBottomNav()
        })

        // Initial render and scene check
        renderScript(data)
        updateCurrentScene()
      }

      // Wait for DOM to be ready before initializing
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init)
      } else {
        init()
      }

      function toggleSidebar() {
        const sidebar = document.querySelector('.sidebar')
        const overlay = document.querySelector('.sidebar-overlay')
        const navToggle = document.querySelector('.nav-toggle')
        
        sidebar.classList.toggle('active')
        overlay.classList.toggle('active')
        
        // Update button text
        navToggle.textContent = sidebar.classList.contains('active') ? '×' : '☰'
      }

      function closeSidebar() {
        const sidebar = document.querySelector('.sidebar')
        const overlay = document.querySelector('.sidebar-overlay')
        const navToggle = document.querySelector('.nav-toggle')
        
        sidebar.classList.remove('active')
        overlay.classList.remove('active')
        navToggle.textContent = '☰'
      }

      // Add this function before updateCurrentScene
      function getCurrentSceneFromScroll() {
        const scenes = document.querySelectorAll('[name^="scene-"]')
        let currentScene = null
        
        for (const scene of scenes) {
          const rect = scene.getBoundingClientRect()
          if (rect.top <= 100) { // Adjust this value based on your navbar height
            currentScene = scene
          } else {
            break
          }
        }
        
        return currentScene ? currentScene.getAttribute('name').replace('scene-', '') : 'Kolpingtheater Ramsen - Drehbuch Viewer'
      }

      function updateCurrentScene() {
        const currentSceneEl = document.getElementById('current-scene')
        const currentScene = getCurrentSceneFromScroll()
      
        if (currentScene) {
          currentSceneEl.textContent = `Szene ${currentScene}`
          // add Role Name if it's not empty and scene is numeric
          const roleName = document.getElementById('actor-select').value
          if (parseInt(currentScene) && roleName) {
            currentSceneEl.textContent += ` - ${roleName}`
          }
          // Only update hash if it's different to avoid unnecessary history entries
          const currentHash = window.location.hash.replace('#scene-', '')
          if (currentHash !== currentScene) {
            history.replaceState(null, null, `#scene-${currentScene}`)
          }
        } else {
          currentSceneEl.textContent = ''
        }
      }

      function findActorLines(actor) {
        const lines = []
        const scriptData = window.scriptData
        
        scriptData.forEach((row, index) => {
          if (row.Charakter === actor) {
            lines.push({
              index: index,
              scene: row.Szene,
              text: row['Text/Anweisung']
            })
          }
        })
        
        return lines
      }

      function getCurrentLineIndex(actorLines) {
        const currentSceneNum = getCurrentSceneFromScroll()
        const scrollPos = window.scrollY
        
        // Find all script line elements for the actor
        const lineElements = document.querySelectorAll('.script-line.highlighted')
        
        // Find which line is closest to the middle of the viewport
        let closestIndex = 0
        let closestDistance = Infinity
        
        // Find which line is closest to the middle of the viewport
        for (let i = 0; i < lineElements.length; i++) {
          const rect = lineElements[i].getBoundingClientRect()
          const distanceToMiddle = Math.abs(rect.top - window.innerHeight / 2)
          
          if (distanceToMiddle < closestDistance) {
            closestDistance = distanceToMiddle
            closestIndex = i
          }
        }
        
        return closestIndex
      }

      function jumpToLine(lineIndex) {
        const lines = document.querySelectorAll('.script-line.highlighted')
        if (lines[lineIndex]) {
          // Remove any existing flash effects
          document.querySelectorAll('.flash-highlight').forEach(el => {
            el.classList.remove('flash-highlight')
          })

          // Add flash effect
          lines[lineIndex].classList.add('flash-highlight')
          
          // Remove the class after animation completes
          lines[lineIndex].addEventListener('animationend', () => {
            lines[lineIndex].classList.remove('flash-highlight')
          }, { once: true })

          // Scroll to the line
          lines[lineIndex].scrollIntoView({ behavior: 'smooth', block: 'center' })
          updateCurrentLineInfo(lineIndex, lines.length)
        }
      }

      function jumpToNextLine() {
        const lines = document.querySelectorAll('.script-line.highlighted')
        const currentIndex = getCurrentLineIndex(lines)
        // If at the end, jump to the beginning, otherwise go to next line
        const nextIndex = currentIndex >= lines.length - 1 ? 0 : currentIndex + 1
        jumpToLine(nextIndex)
      }

      function jumpToPreviousLine() {
        const lines = document.querySelectorAll('.script-line.highlighted')
        const currentIndex = getCurrentLineIndex(lines)
        // If at the beginning, jump to the end, otherwise go to previous line
        const prevIndex = currentIndex <= 0 ? lines.length - 1 : currentIndex - 1
        jumpToLine(prevIndex)
      }

      function updateCurrentLineInfo(currentIndex, totalLines) {
        const infoElement = document.getElementById('current-line-info')
        infoElement.textContent = `Text ${currentIndex + 1} von ${totalLines}`
      }

      function updateBottomNav() {
        const selectedActor = document.getElementById('actor-select').value
        const bottomNav = document.querySelector('.bottom-nav')

        if (selectedActor) {
          bottomNav.style.display = 'flex'
          document.body.classList.add('has-bottom-nav')
          
          const lines = document.querySelectorAll('.script-line.highlighted')
          const currentIndex = getCurrentLineIndex(lines)
          updateCurrentLineInfo(currentIndex, lines.length)
        } else {
          bottomNav.style.display = 'none'
          document.body.classList.remove('has-bottom-nav')
        }
      }

      // Add keyboard navigation
      document.addEventListener('keydown', (e) => {
        const selectedActor = document.getElementById('actor-select').value
        if (!selectedActor) return
        
        if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
          e.preventDefault()
          jumpToNextLine()
        } else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
          e.preventDefault()
          jumpToPreviousLine()
        }
      })
    </script>
  </head>
  <body>
    <!-- Navigation Bar -->
    <div class="nav-bar">
      <h1 id="current-scene">Kolpingtheater Ramsen - Drehbuch Viewer</h1>
      <button class="nav-toggle" onclick="toggleSidebar()">☰</button>
    </div>

    <!-- Sidebar and Overlay -->
    <div class="sidebar"></div>
    <div class="sidebar-overlay" onclick="closeSidebar()"></div>

    <div class="controls no-print">
      <h3>Einstellungen</h3>
      <div>
        <label for="actor-select">Schauspieler auswählen:</label>
        <div class="select-container">
          <select id="actor-select">
            <option value="">Alle Schauspieler</option>
          </select>
        </div>
      </div>

      <div id="checkboxes">
        <div class="checkbox-group">
          <input type="checkbox" id="blur-lines" />
          <label for="blur-lines">Meine Text verstecken</label>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="show-directions" checked />
          <label for="show-directions">Bühnenanweisungen anzeigen</label>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="show-technical" checked />
          <label for="show-technical">Technische Informationen anzeigen</label>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="show-lighting" checked />
          <label for="show-lighting">Beleuchtungshinweise anzeigen</label>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="show-actor-text" checked />
          <label for="show-actor-text">Schauspielertexte anzeigen</label>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="show-micro" checked />
          <label for="show-micro">Mikrofon anzeigen</label>
        </div>

        <!-- Einspieler -->
        <div class="checkbox-group">
          <input type="checkbox" id="show-einspieler" checked />
          <label for="show-einspieler">Einspieler anzeigen</label>
        </div>

        <!-- Szenenübersicht -->
        <div class="checkbox-group">
          <input type="checkbox" id="show-scene-overview" checked />
          <label for="show-scene-overview">Szenenübersicht anzeigen</label>
        </div>

        <!-- Dark Mode -->
        <div class="checkbox-group">
          <input type="checkbox" id="dark-mode" />
          <label for="dark-mode">Dark Mode</label>
        </div>

        <!-- Pink Mode -->
        <div class="checkbox-group">
          <input type="checkbox" id="pink-mode" />
          <label for="pink-mode">Pink Mode</label>
        </div>

        <div>
          <button onclick="window.print()">Als PDF drucken</button>
        </div>
      </div>
    </div>

    <div id="script-container" class="script-container">
      <!-- Script content will be inserted here -->
    </div>

    <!-- Cloudflare Web Analytics -->
    <script
      defer
      src="https://static.cloudflareinsights.com/beacon.min.js"
      data-cf-beacon='{"token": "27138ece224540ad8edd62c49b5f6db4"}'
    ></script>
    <!-- End Cloudflare Web Analytics -->

    <div class="bottom-nav">
      <button onclick="jumpToPreviousLine()">←</button>
      <span id="current-line-info"></span>
      <button onclick="jumpToNextLine()">→</button>
    </div>
  </body>
</html>
